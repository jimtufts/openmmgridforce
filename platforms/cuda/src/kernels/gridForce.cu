/**
 * CUDA implementation of grid force calculation.
 */

// Cubic B-spline basis functions
__device__ inline float bspline_basis0(float t) { return (1.0f - t) * (1.0f - t) * (1.0f - t) / 6.0f; }
__device__ inline float bspline_basis1(float t) { return (3.0f * t * t * t - 6.0f * t * t + 4.0f) / 6.0f; }
__device__ inline float bspline_basis2(float t) { return (-3.0f * t * t * t + 3.0f * t * t + 3.0f * t + 1.0f) / 6.0f; }
__device__ inline float bspline_basis3(float t) { return t * t * t / 6.0f; }

// Derivatives of cubic B-spline basis functions
__device__ inline float bspline_deriv0(float t) { return -(1.0f - t) * (1.0f - t) / 2.0f; }
__device__ inline float bspline_deriv1(float t) { return (3.0f * t * t - 4.0f * t) / 2.0f; }
__device__ inline float bspline_deriv2(float t) { return (-3.0f * t * t + 2.0f * t + 1.0f) / 2.0f; }
__device__ inline float bspline_deriv3(float t) { return t * t / 2.0f; }

/**
 * RASPA3 Triquintic Hermite interpolation transformation matrix (216x216).
 * Converts 216 derivative values (27 derivatives × 8 corners) to polynomial coefficients.
 * Usage: a[i] = 0.125 * sum_j(TRIQUINTIC_COEFFICIENTS[i][j] * X[j])
 *
 * Adapted from RASPA3 molecular simulation code (MIT license)
 * https://github.com/iRASPA/RASPA3
 */
__device__ const float TRIQUINTIC_COEFFICIENTS[216][216] = {
    {8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-80, 80,  0, 0, 0, 0, 0, 0, -48, -32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   -12, 4, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {120, -120, 0,  0, 0, 0, 0, 0, 64, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   12,   -8, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,    0,  0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,    0,  0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,    0,  0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,    0,  0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,    0,  0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {-48, 48, 0, 0, 0, 0, 0, 0, -24, -24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   -4, 4, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,  0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,  0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,  0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,  0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0,   0,  0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, -80, 80, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, -48, -32, 0, 0, 0, 0, 0, 0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  -12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 120, -120, 0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 56, 0, 0, 0, 0, 0, 0,   0,    0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0,   0,    12, -8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0,   0,    0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0,   0,    0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0,   0,    0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0, 0, 0, 0, 0, 0,   0,    0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, -48, 48, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, -24, -24, 0, 0, 0, 0, 0, 0,   0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  -4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0,   0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -40, 40, 0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, -24, -16, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, -6, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,   0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, -60, 0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,   0, 0, 32, 28, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,   0, 0, 0,  0,  0, 0, 6, -4, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,   0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,   0, 0, 0,  0,  0, 0, 0, 0,  0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -24, 24, 0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, -12, -12, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0, 0,
     0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0, 0, 0},
    {-80, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -48, 0, -32, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, -12, 0, 4, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0},
    {0, 0, 0, 0,   0, 0, 0, 0, -80, 0,   80, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,   0, 0, 0, 0, 0,   -48, 0,  -32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,   0, 0, 0, 0, 0,   0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, -12, 0, 4, 0, 0, 0,   0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,   0, 0, 0, 0, 0,   0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,   0, 0, 0, 0, 0,   0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,   0, 0, 0, 0, 0,   0,   0,  0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, -40, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, -24, 0, -16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, -6, 0, 2, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0},
    {800, -800, -800, 800, 0, 0, 0, 0, 480, 320,  -480, -320, 0, 0, 0, 0, 480, -480, 320, -320, 0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 120, -40,  -120, 40,   0, 0, 0, 0, 288, 192,  192, 128,  0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 120, -120, -40,  40,   0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 72,  -24,  48,   -16,  0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     72,  48,   -24,  -16, 0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 18,  -6,   -6,  2,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0},
    {-1200, 1200, 1200, -1200, 0, 0, 0, 0, -640, -560, 640, 560, 0, 0, 0, 0, -720, 720,  -480, 480,  0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -120, 80,   120, -80, 0, 0, 0, 0, -384, -336, -256, -224, 0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -180, 180,  60,  -60, 0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -72,  48,   -48, 32,  0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     -96,   -84,  32,   28,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, -18,  12,   6,    -4,   0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0},
    {480, -480, -480, 480, 0, 0, 0, 0, 240, 240, -240, -240, 0, 0, 0, 0, 288, -288, 192, -192, 0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 40,  -40, -40,  40,   0, 0, 0, 0, 144, 144,  96,  96,   0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 72,  -72, -24,  24,   0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 24,  -24, 16,   -16,  0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     36,  36,   -12,  -12, 0, 0, 0, 0, 0,   0,   0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,   0,    0,    0, 0, 0, 0, 6,   -6,   -2,  2,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,   0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,   0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,   0,    0,    0,   0, 0, 0, 0, 0,   0,   0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0},
    {120, 0, -120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 56, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 12, 0, -8, 0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0,
     0,   0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0},
    {0, 0, 0, 0,  0, 0,  0, 0, 120, 0,  -120, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,  0, 0,  0, 0, 0,   64, 0,    56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,  0, 0,  0, 0, 0,   0,  0,    0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 12, 0, -8, 0, 0, 0,   0,  0,    0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,  0, 0,  0, 0, 0,   0,  0,    0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,  0, 0,  0, 0, 0,   0,  0,    0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0,  0, 0,  0, 0, 0,   0,  0,    0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 60, 0, -60, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0,   0,
     0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0,   0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, -4, 0, 0,  0, 0,   0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0,   0,
     0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,  0, 0,   0},
    {-1200, 1200, 1200, -1200, 0, 0, 0, 0, -720, -480, 720, 480, 0, 0, 0, 0, -640, 640,  -560, 560,  0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -180, 60,   180, -60, 0, 0, 0, 0, -384, -256, -336, -224, 0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -120, 120,  80,  -80, 0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, -96,  32,   -84, 28,  0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     -72,   -48,  48,   32,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, -18,  6,    12,   -4,   0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,     0,    0,    0,     0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0},
    {1800, -1800, -1800, 1800, 0, 0, 0, 0, 960, 840,  -960, -840, 0, 0, 0, 0, 960, -960, 840, -840, 0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 180, -120, -180, 120,  0, 0, 0, 0, 512, 448,  448, 392,  0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 180, -180, -120, 120,  0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 96,  -64,  84,   -56,  0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     96,   84,    -64,   -56,  0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 18,  -12,  -12, 8,    0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0,
     0,    0,     0,     0,    0, 0, 0, 0, 0,   0,    0,    0,    0, 0, 0, 0, 0,   0,    0,   0,    0, 0, 0, 0},
    {-720, 720, 720, -720, 0, 0, 0, 0, -360, -360, 360, 360, 0, 0, 0, 0, -384, 384,  -336, 336,  0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, -60,  60,   60,  -60, 0, 0, 0, 0, -192, -192, -168, -168, 0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, -72,  72,   48,  -48, 0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, -32,  32,   -28, 28,  0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     -36,  -36, 24,  24,   0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, -6,   6,    4,    -4,   0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0,
     0,    0,   0,   0,    0, 0, 0, 0, 0,    0,    0,   0,   0, 0, 0, 0, 0,    0,    0,    0,    0, 0, 0, 0},
    {-48, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -24, 0, -24, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, -4, 0, 4, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0,
     0,   0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0,   0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0}
};

/**
 * Compute all 27 derivatives at each grid point using finite differences.
 * Operates on the capped grid values to avoid singularities.
 * Output: derivatives[27][nx][ny][nz] where derivatives are in physical coordinates.
 */
extern "C" __global__ void computeDerivativesKernel(
    float* __restrict__ derivatives,      // Output: 27 * totalGridPoints
    const float* __restrict__ gridValues, // Input: capped grid values
    const int* __restrict__ gridCounts,
    const float* __restrict__ gridSpacing,
    const int totalGridPoints) {

    const unsigned int gridIdx = blockIdx.x * blockDim.x + threadIdx.x;
    if (gridIdx >= totalGridPoints)
        return;

    // Convert linear index to 3D coordinates
    const int nyz = gridCounts[1] * gridCounts[2];
    const int nx = gridCounts[0];
    const int ny = gridCounts[1];
    const int nz = gridCounts[2];

    const int ix = gridIdx / nyz;
    const int remainder = gridIdx % nyz;
    const int iy = remainder / nz;
    const int iz = remainder % nz;

    const float dx = gridSpacing[0];
    const float dy = gridSpacing[1];
    const float dz = gridSpacing[2];

    const float f = gridValues[gridIdx];

    // Helper macro to safely get grid value with clamped indices
    #define GET_VAL(i, j, k) gridValues[min(max((i), 0), nx-1) * nyz + min(max((j), 0), ny-1) * nz + min(max((k), 0), nz-1)]

    // First derivatives in CELL-FRACTIONAL coordinates (not physical)
    // For triquintic: s ∈ [0,1] within cell, so df/ds = (f[i+1] - f[i-1]) / 2
    float dx_f, dy_f, dz_f;
    if (ix == 0) {
        dx_f = (GET_VAL(ix+1, iy, iz) - f);
    } else if (ix == nx-1) {
        dx_f = (f - GET_VAL(ix-1, iy, iz));
    } else {
        dx_f = (GET_VAL(ix+1, iy, iz) - GET_VAL(ix-1, iy, iz)) / 2.0f;
    }

    if (iy == 0) {
        dy_f = (GET_VAL(ix, iy+1, iz) - f);
    } else if (iy == ny-1) {
        dy_f = (f - GET_VAL(ix, iy-1, iz));
    } else {
        dy_f = (GET_VAL(ix, iy+1, iz) - GET_VAL(ix, iy-1, iz)) / 2.0f;
    }

    if (iz == 0) {
        dz_f = (GET_VAL(ix, iy, iz+1) - f);
    } else if (iz == nz-1) {
        dz_f = (f - GET_VAL(ix, iy, iz-1));
    } else {
        dz_f = (GET_VAL(ix, iy, iz+1) - GET_VAL(ix, iy, iz-1)) / 2.0f;
    }

    // Second derivatives in CELL-FRACTIONAL coordinates
    float dxx_f, dyy_f, dzz_f, dxy_f, dxz_f, dyz_f;

    // dxx: use one-sided at boundaries
    if (ix == 0 && nx >= 3) {
        dxx_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix+1, iy, iz) + GET_VAL(ix+2, iy, iz));
    } else if (ix == nx-1 && nx >= 3) {
        dxx_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix-1, iy, iz) + GET_VAL(ix-2, iy, iz));
    } else if (nx >= 3) {
        dxx_f = (GET_VAL(ix+1, iy, iz) - 2.0f*f + GET_VAL(ix-1, iy, iz));
    } else {
        dxx_f = 0.0f;
    }

    // dyy: use one-sided at boundaries
    if (iy == 0 && ny >= 3) {
        dyy_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix, iy+2, iz));
    } else if (iy == ny-1 && ny >= 3) {
        dyy_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix, iy-2, iz));
    } else if (ny >= 3) {
        dyy_f = (GET_VAL(ix, iy+1, iz) - 2.0f*f + GET_VAL(ix, iy-1, iz));
    } else {
        dyy_f = 0.0f;
    }

    // dzz: use one-sided at boundaries
    if (iz == 0 && nz >= 3) {
        dzz_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix, iy, iz+2));
    } else if (iz == nz-1 && nz >= 3) {
        dzz_f = (GET_VAL(ix, iy, iz) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix, iy, iz-2));
    } else if (nz >= 3) {
        dzz_f = (GET_VAL(ix, iy, iz+1) - 2.0f*f + GET_VAL(ix, iy, iz-1));
    } else {
        dzz_f = 0.0f;
    }

    // Mixed second derivatives: use centered if available, one-sided at boundaries
    if (ix == 0 || ix == nx-1 || iy == 0 || iy == ny-1) {
        // Use simple one-sided approximation for dxy at boundaries
        float dx_yp = (ix == nx-1) ? (GET_VAL(ix, iy+1, iz) - GET_VAL(ix-1, iy+1, iz)) :
                                      (GET_VAL(ix+1, iy+1, iz) - GET_VAL(ix, iy+1, iz));
        float dx_ym = (ix == nx-1) ? (GET_VAL(ix, iy-1, iz) - GET_VAL(ix-1, iy-1, iz)) :
                                      (GET_VAL(ix+1, iy-1, iz) - GET_VAL(ix, iy-1, iz));
        dxy_f = (iy == ny-1) ? (dx_ym) : (iy == 0) ? (dx_yp) : (dx_yp - dx_ym) / 2.0f;
    } else {
        dxy_f = (GET_VAL(ix+1, iy+1, iz) - GET_VAL(ix+1, iy-1, iz) -
                 GET_VAL(ix-1, iy+1, iz) + GET_VAL(ix-1, iy-1, iz)) / 4.0f;
    }

    if (ix == 0 || ix == nx-1 || iz == 0 || iz == nz-1) {
        // Use simple one-sided approximation for dxz at boundaries
        float dx_zp = (ix == nx-1) ? (GET_VAL(ix, iy, iz+1) - GET_VAL(ix-1, iy, iz+1)) :
                                      (GET_VAL(ix+1, iy, iz+1) - GET_VAL(ix, iy, iz+1));
        float dx_zm = (ix == nx-1) ? (GET_VAL(ix, iy, iz-1) - GET_VAL(ix-1, iy, iz-1)) :
                                      (GET_VAL(ix+1, iy, iz-1) - GET_VAL(ix, iy, iz-1));
        dxz_f = (iz == nz-1) ? (dx_zm) : (iz == 0) ? (dx_zp) : (dx_zp - dx_zm) / 2.0f;
    } else {
        dxz_f = (GET_VAL(ix+1, iy, iz+1) - GET_VAL(ix+1, iy, iz-1) -
                 GET_VAL(ix-1, iy, iz+1) + GET_VAL(ix-1, iy, iz-1)) / 4.0f;
    }

    if (iy == 0 || iy == ny-1 || iz == 0 || iz == nz-1) {
        // Use simple one-sided approximation for dyz at boundaries
        float dy_zp = (iy == ny-1) ? (GET_VAL(ix, iy, iz+1) - GET_VAL(ix, iy-1, iz+1)) :
                                      (GET_VAL(ix, iy+1, iz+1) - GET_VAL(ix, iy, iz+1));
        float dy_zm = (iy == ny-1) ? (GET_VAL(ix, iy, iz-1) - GET_VAL(ix, iy-1, iz-1)) :
                                      (GET_VAL(ix, iy+1, iz-1) - GET_VAL(ix, iy, iz-1));
        dyz_f = (iz == nz-1) ? (dy_zm) : (iz == 0) ? (dy_zp) : (dy_zp - dy_zm) / 2.0f;
    } else {
        dyz_f = (GET_VAL(ix, iy+1, iz+1) - GET_VAL(ix, iy+1, iz-1) -
                 GET_VAL(ix, iy-1, iz+1) + GET_VAL(ix, iy-1, iz-1)) / 4.0f;
    }

    // Higher order derivatives
    // Use helper macro with bounds checking
    #define GET_VAL(i, j, k) gridValues[min(max((i), 0), nx-1) * nyz + min(max((j), 0), ny-1) * nz + min(max((k), 0), nz-1)]

    float dxxy_f = 0.0f, dxxz_f = 0.0f, dxyy_f = 0.0f, dxyz_f = 0.0f;
    float dxzz_f = 0.0f, dyyz_f = 0.0f, dyzz_f = 0.0f;
    float dxxyy_f = 0.0f, dxxzz_f = 0.0f, dyyzz_f = 0.0f;
    float dxxyz_f = 0.0f, dxyyz_f = 0.0f, dxyzz_f = 0.0f;
    float dxxyyz_f = 0.0f, dxxyzz_f = 0.0f, dxyyzz_f = 0.0f, dxxyyzz_f = 0.0f;

    // Check if we have enough neighbors for higher-order derivatives
    // Need at least nx,ny,nz >= 3 to compute these derivatives
    const bool can_compute = (nx >= 3 && ny >= 3 && nz >= 3);

    if (can_compute) {
        // Third derivatives (7 unique)
        // dxxy = d/dy(dxx) = d/dy(f[i+1] - 2*f[i] + f[i-1])
        dxxy_f = ((GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix-1, iy+1, iz)) -
                  (GET_VAL(ix+1, iy-1, iz) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix-1, iy-1, iz))) / 2.0f;

        // dxxz = d/dz(dxx)
        dxxz_f = ((GET_VAL(ix+1, iy, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix-1, iy, iz+1)) -
                  (GET_VAL(ix+1, iy, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix-1, iy, iz-1))) / 2.0f;

        // dxyy = d/dx(dyy)
        dxyy_f = ((GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix+1, iy, iz) + GET_VAL(ix+1, iy-1, iz)) -
                  (GET_VAL(ix-1, iy+1, iz) - 2.0f*GET_VAL(ix-1, iy, iz) + GET_VAL(ix-1, iy-1, iz))) / 2.0f;

        // dyyz = d/dz(dyy)
        dyyz_f = ((GET_VAL(ix, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix, iy-1, iz+1)) -
                  (GET_VAL(ix, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix, iy-1, iz-1))) / 2.0f;

        // dxzz = d/dx(dzz)
        dxzz_f = ((GET_VAL(ix+1, iy, iz+1) - 2.0f*GET_VAL(ix+1, iy, iz) + GET_VAL(ix+1, iy, iz-1)) -
                  (GET_VAL(ix-1, iy, iz+1) - 2.0f*GET_VAL(ix-1, iy, iz) + GET_VAL(ix-1, iy, iz-1))) / 2.0f;

        // dyzz = d/dy(dzz)
        dyzz_f = ((GET_VAL(ix, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix, iy+1, iz-1)) -
                  (GET_VAL(ix, iy-1, iz+1) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix, iy-1, iz-1))) / 2.0f;

        // dxyz = d/dz(dxy) - mixed partial derivative
        dxyz_f = ((GET_VAL(ix+1, iy+1, iz+1) - GET_VAL(ix+1, iy-1, iz+1) -
                   GET_VAL(ix-1, iy+1, iz+1) + GET_VAL(ix-1, iy-1, iz+1)) -
                  (GET_VAL(ix+1, iy+1, iz-1) - GET_VAL(ix+1, iy-1, iz-1) -
                   GET_VAL(ix-1, iy+1, iz-1) + GET_VAL(ix-1, iy-1, iz-1))) / 8.0f;

        // Fourth derivatives (6 unique)
        // dxxyy = d²/dy²(dxx) = d/dy(dxxy)
        dxxyy_f = ((GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix-1, iy+1, iz)) -
                   2.0f*(GET_VAL(ix+1, iy, iz) - 2.0f*f + GET_VAL(ix-1, iy, iz)) +
                   (GET_VAL(ix+1, iy-1, iz) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix-1, iy-1, iz)));

        // dxxzz = d²/dz²(dxx)
        dxxzz_f = ((GET_VAL(ix+1, iy, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix-1, iy, iz+1)) -
                   2.0f*(GET_VAL(ix+1, iy, iz) - 2.0f*f + GET_VAL(ix-1, iy, iz)) +
                   (GET_VAL(ix+1, iy, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix-1, iy, iz-1)));

        // dyyzz = d²/dz²(dyy)
        dyyzz_f = ((GET_VAL(ix, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix, iy-1, iz+1)) -
                   2.0f*(GET_VAL(ix, iy+1, iz) - 2.0f*f + GET_VAL(ix, iy-1, iz)) +
                   (GET_VAL(ix, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix, iy-1, iz-1)));

        // dxxyz = d/dy(dxxz) - or equivalently d/dz(dxxy)
        dxxyz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy+1, iz+1) + GET_VAL(ix-1, iy+1, iz+1)) -
                    (GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy+1, iz-1) + GET_VAL(ix-1, iy+1, iz-1))) -
                   ((GET_VAL(ix+1, iy-1, iz+1) - 2.0f*GET_VAL(ix, iy-1, iz+1) + GET_VAL(ix-1, iy-1, iz+1)) -
                    (GET_VAL(ix+1, iy-1, iz-1) - 2.0f*GET_VAL(ix, iy-1, iz-1) + GET_VAL(ix-1, iy-1, iz-1)))) / 4.0f;

        // dxyyz = d/dz(dxyy) - or equivalently d/dy(dxyz)
        dxyyz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix+1, iy, iz+1) + GET_VAL(ix+1, iy-1, iz+1)) -
                    (GET_VAL(ix-1, iy+1, iz+1) - 2.0f*GET_VAL(ix-1, iy, iz+1) + GET_VAL(ix-1, iy-1, iz+1))) -
                   ((GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix+1, iy, iz-1) + GET_VAL(ix+1, iy-1, iz-1)) -
                    (GET_VAL(ix-1, iy+1, iz-1) - 2.0f*GET_VAL(ix-1, iy, iz-1) + GET_VAL(ix-1, iy-1, iz-1)))) / 4.0f;

        // dxyzz = d/dx(dyzz) - or equivalently d/dz(dxyz)
        dxyzz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix+1, iy+1, iz) + GET_VAL(ix+1, iy+1, iz-1)) -
                    (GET_VAL(ix+1, iy-1, iz+1) - 2.0f*GET_VAL(ix+1, iy-1, iz) + GET_VAL(ix+1, iy-1, iz-1))) -
                   ((GET_VAL(ix-1, iy+1, iz+1) - 2.0f*GET_VAL(ix-1, iy+1, iz) + GET_VAL(ix-1, iy+1, iz-1)) -
                    (GET_VAL(ix-1, iy-1, iz+1) - 2.0f*GET_VAL(ix-1, iy-1, iz) + GET_VAL(ix-1, iy-1, iz-1)))) / 4.0f;

        // Fifth derivatives (3 unique)
        // dxxyyz = d/dz(dxxyy) - or equivalently d/dy(dxxyz)
        dxxyyz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy+1, iz+1) + GET_VAL(ix-1, iy+1, iz+1)) -
                     2.0f*(GET_VAL(ix+1, iy, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix-1, iy, iz+1)) +
                     (GET_VAL(ix+1, iy-1, iz+1) - 2.0f*GET_VAL(ix, iy-1, iz+1) + GET_VAL(ix-1, iy-1, iz+1))) -
                    ((GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy+1, iz-1) + GET_VAL(ix-1, iy+1, iz-1)) -
                     2.0f*(GET_VAL(ix+1, iy, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix-1, iy, iz-1)) +
                     (GET_VAL(ix+1, iy-1, iz-1) - 2.0f*GET_VAL(ix, iy-1, iz-1) + GET_VAL(ix-1, iy-1, iz-1)))) / 2.0f;

        // dxxyzz = d/dy(dxxzz) - or equivalently d/dz(dxxyz)
        dxxyzz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy+1, iz+1) + GET_VAL(ix-1, iy+1, iz+1)) -
                     2.0f*(GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix-1, iy+1, iz)) +
                     (GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy+1, iz-1) + GET_VAL(ix-1, iy+1, iz-1))) -
                    ((GET_VAL(ix+1, iy-1, iz+1) - 2.0f*GET_VAL(ix, iy-1, iz+1) + GET_VAL(ix-1, iy-1, iz+1)) -
                     2.0f*(GET_VAL(ix+1, iy-1, iz) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix-1, iy-1, iz)) +
                     (GET_VAL(ix+1, iy-1, iz-1) - 2.0f*GET_VAL(ix, iy-1, iz-1) + GET_VAL(ix-1, iy-1, iz-1)))) / 2.0f;

        // dxyyzz = d/dx(dyyzz) - or equivalently d/dy(dxyzz) - or equivalently d/dz(dxyyz)
        dxyyzz_f = (((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix+1, iy, iz+1) + GET_VAL(ix+1, iy-1, iz+1)) -
                     2.0f*(GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix+1, iy, iz) + GET_VAL(ix+1, iy-1, iz)) +
                     (GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix+1, iy, iz-1) + GET_VAL(ix+1, iy-1, iz-1))) -
                    ((GET_VAL(ix-1, iy+1, iz+1) - 2.0f*GET_VAL(ix-1, iy, iz+1) + GET_VAL(ix-1, iy-1, iz+1)) -
                     2.0f*(GET_VAL(ix-1, iy+1, iz) - 2.0f*GET_VAL(ix-1, iy, iz) + GET_VAL(ix-1, iy-1, iz)) +
                     (GET_VAL(ix-1, iy+1, iz-1) - 2.0f*GET_VAL(ix-1, iy, iz-1) + GET_VAL(ix-1, iy-1, iz-1)))) / 2.0f;

        // Sixth derivative (1 unique)
        // dxxyyzz = d/dz(dxxyy) - or d/dy(dxxyzz) - or d/dx(dxyyzz)
        dxxyyzz_f = ((GET_VAL(ix+1, iy+1, iz+1) - 2.0f*GET_VAL(ix, iy+1, iz+1) + GET_VAL(ix-1, iy+1, iz+1)) -
                     2.0f*(GET_VAL(ix+1, iy, iz+1) - 2.0f*GET_VAL(ix, iy, iz+1) + GET_VAL(ix-1, iy, iz+1)) +
                     (GET_VAL(ix+1, iy-1, iz+1) - 2.0f*GET_VAL(ix, iy-1, iz+1) + GET_VAL(ix-1, iy-1, iz+1))) -
                    2.0f*((GET_VAL(ix+1, iy+1, iz) - 2.0f*GET_VAL(ix, iy+1, iz) + GET_VAL(ix-1, iy+1, iz)) -
                          2.0f*(GET_VAL(ix+1, iy, iz) - 2.0f*f + GET_VAL(ix-1, iy, iz)) +
                          (GET_VAL(ix+1, iy-1, iz) - 2.0f*GET_VAL(ix, iy-1, iz) + GET_VAL(ix-1, iy-1, iz))) +
                    ((GET_VAL(ix+1, iy+1, iz-1) - 2.0f*GET_VAL(ix, iy+1, iz-1) + GET_VAL(ix-1, iy+1, iz-1)) -
                     2.0f*(GET_VAL(ix+1, iy, iz-1) - 2.0f*GET_VAL(ix, iy, iz-1) + GET_VAL(ix-1, iy, iz-1)) +
                     (GET_VAL(ix+1, iy-1, iz-1) - 2.0f*GET_VAL(ix, iy-1, iz-1) + GET_VAL(ix-1, iy-1, iz-1)));
    }

    #undef GET_VAL

    // Convert to LOGARITHMIC derivatives for efficient power transformations
    // L1 = G'/G, L2 = G''/G, etc.
    // This allows: H=G^n => H'=n*H*L1, H''=H*(n*L2 + n*(n-1)*L1²)
    const float epsilon = 1e-10f;  // Avoid division by zero
    const float f_safe = (fabsf(f) < epsilon) ? copysignf(epsilon, f) : f;

    // First logarithmic derivatives: L1_x = dx_f / f, etc.
    float L1_x = dx_f / f_safe;
    float L1_y = dy_f / f_safe;
    float L1_z = dz_f / f_safe;

    // Second logarithmic derivatives: L2_xx = dxx_f / f, etc.
    float L2_xx = dxx_f / f_safe;
    float L2_yy = dyy_f / f_safe;
    float L2_zz = dzz_f / f_safe;
    float L2_xy = dxy_f / f_safe;
    float L2_xz = dxz_f / f_safe;
    float L2_yz = dyz_f / f_safe;

    // Third logarithmic derivatives: L3_xxy = dxxy_f / f, etc.
    float L3_xxy = dxxy_f / f_safe;
    float L3_xxz = dxxz_f / f_safe;
    float L3_xyy = dxyy_f / f_safe;
    float L3_xyz = dxyz_f / f_safe;
    float L3_yzz = dyzz_f / f_safe;
    float L3_xzz = dxzz_f / f_safe;
    float L3_yyz = dyyz_f / f_safe;

    // Fourth logarithmic derivatives: L4_xxyy = dxxyy_f / f, etc.
    float L4_xxyy = dxxyy_f / f_safe;
    float L4_xxzz = dxxzz_f / f_safe;
    float L4_yyzz = dyyzz_f / f_safe;
    float L4_xxyz = dxxyz_f / f_safe;
    float L4_xyyz = dxyyz_f / f_safe;
    float L4_xyzz = dxyzz_f / f_safe;

    // Fifth logarithmic derivatives: L5_xxyyz = dxxyyz_f / f, etc.
    float L5_xxyyz = dxxyyz_f / f_safe;
    float L5_xxyzz = dxxyzz_f / f_safe;
    float L5_xyyzz = dxyyzz_f / f_safe;

    // Sixth logarithmic derivative: L6_xxyyzz = dxxyyzz_f / f
    float L6_xxyyzz = dxxyyzz_f / f_safe;

    // Store in layout [deriv_idx][x][y][z]
    // Total: 27 derivatives for triquintic Hermite interpolation
    // Layout matches RASPA3: f, dx, dy, dz, dxx, dxy, dxz, dyy, dyz, dzz, dxxy, dxxz, dxyy, dxyz, dyyz, dxzz, dyzz,
    //                        dxxyy, dxxzz, dyyzz, dxxyz, dxyyz, dxyzz, dxxyyz, dxxyzz, dxyyzz, dxxyyzz
    const int offset = gridIdx;
    derivatives[0 * totalGridPoints + offset] = f;          // Function value
    derivatives[1 * totalGridPoints + offset] = L1_x;       // 1st derivatives
    derivatives[2 * totalGridPoints + offset] = L1_y;
    derivatives[3 * totalGridPoints + offset] = L1_z;
    derivatives[4 * totalGridPoints + offset] = L2_xx;      // 2nd derivatives
    derivatives[5 * totalGridPoints + offset] = L2_yy;
    derivatives[6 * totalGridPoints + offset] = L2_zz;
    derivatives[7 * totalGridPoints + offset] = L2_xy;
    derivatives[8 * totalGridPoints + offset] = L2_xz;
    derivatives[9 * totalGridPoints + offset] = L2_yz;
    derivatives[10 * totalGridPoints + offset] = L3_xxy;    // 3rd derivatives
    derivatives[11 * totalGridPoints + offset] = L3_xxz;
    derivatives[12 * totalGridPoints + offset] = L3_xyy;
    derivatives[13 * totalGridPoints + offset] = L3_xyz;
    derivatives[14 * totalGridPoints + offset] = L3_yyz;
    derivatives[15 * totalGridPoints + offset] = L3_xzz;
    derivatives[16 * totalGridPoints + offset] = L3_yzz;
    derivatives[17 * totalGridPoints + offset] = L4_xxyy;   // 4th derivatives
    derivatives[18 * totalGridPoints + offset] = L4_xxzz;
    derivatives[19 * totalGridPoints + offset] = L4_yyzz;
    derivatives[20 * totalGridPoints + offset] = L4_xxyz;
    derivatives[21 * totalGridPoints + offset] = L4_xyyz;
    derivatives[22 * totalGridPoints + offset] = L4_xyzz;
    derivatives[23 * totalGridPoints + offset] = L5_xxyyz;  // 5th derivatives
    derivatives[24 * totalGridPoints + offset] = L5_xxyzz;
    derivatives[25 * totalGridPoints + offset] = L5_xyyzz;
    derivatives[26 * totalGridPoints + offset] = L6_xxyyzz; // 6th derivative
}

/**
 * Generate grid values on GPU.
 * Each thread calculates one grid point by summing contributions from all receptor atoms.
 */
extern "C" __global__ void generateGridKernel(
    float* __restrict__ gridValues,
    const float3* __restrict__ receptorPositions,
    const float* __restrict__ receptorCharges,
    const float* __restrict__ receptorSigmas,
    const float* __restrict__ receptorEpsilons,
    const int numReceptorAtoms,
    const int gridType,  // 0=charge, 1=ljr, 2=lja
    const float gridCap,  // Capping threshold (kJ/mol)
    const float invPower,  // Inverse power transformation
    const float originX,
    const float originY,
    const float originZ,
    const int* __restrict__ gridCounts,
    const float* __restrict__ gridSpacing,
    const int totalGridPoints) {

    // Get grid point index
    const unsigned int gridIdx = blockIdx.x * blockDim.x + threadIdx.x;

    if (gridIdx >= totalGridPoints)
        return;

    // Convert linear index to 3D grid coordinates
    const int nyz = gridCounts[1] * gridCounts[2];
    const int i = gridIdx / nyz;
    const int remainder = gridIdx % nyz;
    const int j = remainder / gridCounts[2];
    const int k = remainder % gridCounts[2];

    // Calculate grid point position (in nm)
    const float gx = originX + i * gridSpacing[0];
    const float gy = originY + j * gridSpacing[1];
    const float gz = originZ + k * gridSpacing[2];

    // Physics constants
    const float COULOMB_CONST = 138.935456f;  // kJ·nm/(mol·e²)
    const float U_MAX = gridCap;              // Configurable capping threshold

    // Calculate contribution from each receptor atom
    float gridValue = 0.0f;
    for (int atomIdx = 0; atomIdx < numReceptorAtoms; atomIdx++) {
        // Get atom position
        float3 atomPos = receptorPositions[atomIdx];

        // Calculate distance
        const float dx = gx - atomPos.x;
        const float dy = gy - atomPos.y;
        const float dz = gz - atomPos.z;
        const float r2 = dx*dx + dy*dy + dz*dz;
        float r = sqrtf(r2);

        // Avoid singularities at very small distances
        if (r < 1e-6f) {
            r = 1e-6f;
        }

        // Calculate contribution based on grid type
        if (gridType == 0) {
            // Electrostatic potential: k * q / r
            gridValue += COULOMB_CONST * receptorCharges[atomIdx] / r;
        } else if (gridType == 1) {
            // LJ repulsive: sqrt(epsilon) * Rmin^6 / r^12
            // where Rmin = 2^(1/6) * sigma (AMBER convention)
            const float rmin = powf(2.0f, 1.0f/6.0f) * receptorSigmas[atomIdx];
            const float r6 = rmin * rmin * rmin * rmin * rmin * rmin;
            const float r12 = r2 * r2 * r2 * r2 * r2 * r2;
            gridValue += sqrtf(receptorEpsilons[atomIdx]) * r6 / r12;
        } else if (gridType == 2) {
            // LJ attractive: -2 * sqrt(epsilon) * Rmin^3 / r^6
            // where Rmin = 2^(1/6) * sigma (AMBER convention)
            const float rmin = powf(2.0f, 1.0f/6.0f) * receptorSigmas[atomIdx];
            const float r3 = rmin * rmin * rmin;
            const float r6 = r2 * r2 * r2;
            gridValue += -2.0f * sqrtf(receptorEpsilons[atomIdx]) * r3 / r6;
        }
    }

    // Apply capping to avoid extreme values
    gridValue = U_MAX * tanhf(gridValue / U_MAX);

    // Apply inverse power transformation if specified
    // Grid should store G^(1/n), kernel will apply ^n to recover G
    if (invPower > 0.0f) {
        gridValue = powf(gridValue, 1.0f / invPower);
    }

    // Store result
    gridValues[gridIdx] = gridValue;
}

extern "C" __global__ void computeGridForce(
    const float4* __restrict__ posq,
    unsigned long long* __restrict__ forceBuffers,
    const int* __restrict__ gridCounts,
    const float* __restrict__ gridSpacing,
    const float* __restrict__ gridValues,
    const float* __restrict__ scalingFactors,
    const float invPower,
    const int interpolationMethod,  // 0=trilinear, 1=B-spline, 2=tricubic, 3=triquintic
    const float outOfBoundsK,
    const float originX,
    const float originY,
    const float originZ,
    const float* __restrict__ gridDerivatives,  // For triquintic: 27 derivatives per point
    float* __restrict__ energyBuffer,
    const int numAtoms,
    const int paddedNumAtoms) {

    // Get thread index
    const unsigned int index = blockIdx.x * blockDim.x + threadIdx.x;
    if (index >= numAtoms)
        return;

    // Load atom position and scaling factor
    float4 posOrig = posq[index];
    float scalingFactor = scalingFactors[index];

    // Transform position to grid coordinates (relative to origin)
    float3 pos;
    pos.x = posOrig.x - originX;
    pos.y = posOrig.y - originY;
    pos.z = posOrig.z - originZ;

    // Initialize force to zero
    float3 atomForce = make_float3(0.0f, 0.0f, 0.0f);
    float threadEnergy = 0.0f;

    // Calculate grid boundaries
    float3 gridCorner;
    gridCorner.x = gridSpacing[0] * (gridCounts[0] - 1);
    gridCorner.y = gridSpacing[1] * (gridCounts[1] - 1);
    gridCorner.z = gridSpacing[2] * (gridCounts[2] - 1);

    // Check if the atom is inside the grid
    bool isInside = (pos.x >= 0.0f && pos.x <= gridCorner.x &&
                    pos.y >= 0.0f && pos.y <= gridCorner.y &&
                    pos.z >= 0.0f && pos.z <= gridCorner.z);

    if (isInside && scalingFactor != 0.0f) {
        // Calculate grid indices
        int ix = min(max((int)(pos.x / gridSpacing[0]), 0), gridCounts[0] - 2);
        int iy = min(max((int)(pos.y / gridSpacing[1]), 0), gridCounts[1] - 2);
        int iz = min(max((int)(pos.z / gridSpacing[2]), 0), gridCounts[2] - 2);

        // Calculate fractional position within the cell
        float fx = (pos.x / gridSpacing[0]) - ix;
        float fy = (pos.y / gridSpacing[1]) - iy;
        float fz = (pos.z / gridSpacing[2]) - iz;

        fx = min(max(fx, 0.0f), 1.0f);
        fy = min(max(fy, 0.0f), 1.0f);
        fz = min(max(fz, 0.0f), 1.0f);

        // Declare variables for interpolation
        float interpolated = 0.0f;
        float dx, dy, dz;
        int nyz = gridCounts[1] * gridCounts[2];

        if (interpolationMethod == 1) {
            // CUBIC B-SPLINE INTERPOLATION (4x4x4 = 64 points)
            // Precompute basis functions
            float bx[4] = {bspline_basis0(fx), bspline_basis1(fx), bspline_basis2(fx), bspline_basis3(fx)};
            float by[4] = {bspline_basis0(fy), bspline_basis1(fy), bspline_basis2(fy), bspline_basis3(fy)};
            float bz[4] = {bspline_basis0(fz), bspline_basis1(fz), bspline_basis2(fz), bspline_basis3(fz)};

            float dbx[4] = {bspline_deriv0(fx), bspline_deriv1(fx), bspline_deriv2(fx), bspline_deriv3(fx)};
            float dby[4] = {bspline_deriv0(fy), bspline_deriv1(fy), bspline_deriv2(fy), bspline_deriv3(fy)};
            float dbz[4] = {bspline_deriv0(fz), bspline_deriv1(fz), bspline_deriv2(fz), bspline_deriv3(fz)};

            float dvdx = 0.0f, dvdy = 0.0f, dvdz = 0.0f;

            // Tri-linear B-spline interpolation
            for (int i = 0; i < 4; i++) {
                int gx = min(max(ix - 1 + i, 0), gridCounts[0] - 1);
                for (int j = 0; j < 4; j++) {
                    int gy = min(max(iy - 1 + j, 0), gridCounts[1] - 1);
                    for (int k = 0; k < 4; k++) {
                        int gz = min(max(iz - 1 + k, 0), gridCounts[2] - 1);
                        int gridIdx = gx * nyz + gy * gridCounts[2] + gz;
                        float val = gridValues[gridIdx];
                        float weight = bx[i] * by[j] * bz[k];
                        interpolated += weight * val;
                        dvdx += dbx[i] * by[j] * bz[k] * val;
                        dvdy += bx[i] * dby[j] * bz[k] * val;
                        dvdz += bx[i] * by[j] * dbz[k] * val;
                    }
                }
            }

            dx = dvdx / gridSpacing[0];
            dy = dvdy / gridSpacing[1];
            dz = dvdz / gridSpacing[2];

        } else if (interpolationMethod == 3 && gridDerivatives != nullptr) {
            // TRIQUINTIC HERMITE INTERPOLATION (requires precomputed derivatives)
            // NOTE: Works best with moderate grid caps (<100k kJ/mol, <5% of grid at cap).
            // At very high caps (>500k), capping artifacts cause polynomial oscillations.
            // Gather 216 derivative values (27 derivatives × 8 corners)
            int totalPoints = gridCounts[0] * gridCounts[1] * gridCounts[2];
            int corners[8][3] = {
                {ix, iy, iz}, {ix+1, iy, iz}, {ix, iy+1, iz}, {ix+1, iy+1, iz},
                {ix, iy, iz+1}, {ix+1, iy, iz+1}, {ix, iy+1, iz+1}, {ix+1, iy+1, iz+1}
            };

            // Gather derivatives in layout: X[deriv_idx * 8 + corner_idx]
            // Derivatives are stored as LOGARITHMIC: L1 = G'/G, L2 = G''/G
            // Need to reconstruct raw derivatives: G' = G * L1, G'' = G * L2
            float X[216];
            for (int c = 0; c < 8; c++) {
                int point_idx = corners[c][0] * nyz + corners[c][1] * gridCounts[2] + corners[c][2];

                // Get function value
                float f = gridDerivatives[0 * totalPoints + point_idx];
                X[0 * 8 + c] = f;

                // Reconstruct first derivatives from logarithmic: G' = G * L1
                for (int d = 1; d <= 3; d++) {
                    float L1 = gridDerivatives[d * totalPoints + point_idx];
                    X[d * 8 + c] = f * L1;
                }

                // Reconstruct second derivatives from logarithmic: G'' = G * L2
                for (int d = 4; d <= 9; d++) {
                    float L2 = gridDerivatives[d * totalPoints + point_idx];
                    X[d * 8 + c] = f * L2;
                }

                // Reconstruct third derivatives from logarithmic: G''' = G * L3
                for (int d = 10; d <= 16; d++) {
                    float L3 = gridDerivatives[d * totalPoints + point_idx];
                    X[d * 8 + c] = f * L3;
                }

                // Reconstruct fourth derivatives from logarithmic: G'''' = G * L4
                for (int d = 17; d <= 22; d++) {
                    float L4 = gridDerivatives[d * totalPoints + point_idx];
                    X[d * 8 + c] = f * L4;
                }

                // Reconstruct fifth derivatives from logarithmic: G''''' = G * L5
                for (int d = 23; d <= 25; d++) {
                    float L5 = gridDerivatives[d * totalPoints + point_idx];
                    X[d * 8 + c] = f * L5;
                }

                // Reconstruct sixth derivative from logarithmic: G'''''' = G * L6
                float L6 = gridDerivatives[26 * totalPoints + point_idx];
                X[26 * 8 + c] = f * L6;
            }

            // Compute polynomial coefficients: a = 0.125 * TRIQUINTIC_COEFFICIENTS * X
            float a[216];
            const float scale = 0.125f;
            for (int i = 0; i < 216; i++) {
                a[i] = 0.0f;
                for (int j = 0; j < 216; j++) {
                    a[i] += TRIQUINTIC_COEFFICIENTS[i][j] * X[j];
                }
                a[i] *= scale;
            }

            // Precompute powers of local coordinates
            float sx_pow[6], sy_pow[6], sz_pow[6];
            sx_pow[0] = sy_pow[0] = sz_pow[0] = 1.0f;
            for (int p = 1; p < 6; p++) {
                sx_pow[p] = sx_pow[p-1] * fx;
                sy_pow[p] = sy_pow[p-1] * fy;
                sz_pow[p] = sz_pow[p-1] * fz;
            }

            // Evaluate polynomial: sum over i,j,k of a[i+6j+36k] * fx^i * fy^j * fz^k
            float value = 0.0f;
            float dvalue_dx = 0.0f, dvalue_dy = 0.0f, dvalue_dz = 0.0f;

            for (int k = 0; k < 6; k++) {
                for (int j = 0; j < 6; j++) {
                    for (int i = 0; i < 6; i++) {
                        int coeff_idx = i + 6*j + 36*k;
                        float coeff = a[coeff_idx];
                        value += coeff * sx_pow[i] * sy_pow[j] * sz_pow[k];
                        if (i > 0) dvalue_dx += coeff * i * sx_pow[i-1] * sy_pow[j] * sz_pow[k];
                        if (j > 0) dvalue_dy += coeff * j * sx_pow[i] * sy_pow[j-1] * sz_pow[k];
                        if (k > 0) dvalue_dz += coeff * k * sx_pow[i] * sy_pow[j] * sz_pow[k-1];
                    }
                }
            }

            interpolated = value;
            // Convert gradients from cell-local [0,1] to physical coordinates
            dx = dvalue_dx / gridSpacing[0];
            dy = dvalue_dy / gridSpacing[1];
            dz = dvalue_dz / gridSpacing[2];

        } else {
            // TRILINEAR INTERPOLATION (default, 2x2x2 = 8 points)
            float ox = 1.0f - fx;
            float oy = 1.0f - fy;
            float oz = 1.0f - fz;

            int baseIndex = ix * nyz + iy * gridCounts[2] + iz;
            int ip = baseIndex + nyz;           // ix+1
            int imp = baseIndex + gridCounts[2]; // iy+1
            int ipp = ip + gridCounts[2];       // ix+1, iy+1

            // Get grid values
            float vmmm = gridValues[baseIndex];
            float vmmp = gridValues[baseIndex + 1];
            float vmpm = gridValues[imp];
            float vmpp = gridValues[imp + 1];
            float vpmm = gridValues[ip];
            float vpmp = gridValues[ip + 1];
            float vppm = gridValues[ipp];
            float vppp = gridValues[ipp + 1];

            // Perform trilinear interpolation
            float vmm = oz * vmmm + fz * vmmp;
            float vmp = oz * vmpm + fz * vmpp;
            float vpm = oz * vpmm + fz * vpmp;
            float vpp = oz * vppm + fz * vppp;

            float vm = oy * vmm + fy * vmp;
            float vp = oy * vpm + fy * vpp;

            interpolated = ox * vm + fx * vp;

            // Calculate forces (gradients)
            dx = (vp - vm) / gridSpacing[0];
            dy = (ox * (vmp - vmm) + fx * (vpp - vpm)) / gridSpacing[1];
            dz = (ox * (oy * (vmmp - vmmm) + fy * (vmpp - vmpm)) +
                   fx * (oy * (vpmp - vpmm) + fy * (vppp - vppm))) / gridSpacing[2];
        }

        // Apply inverse power transformation if specified
        if (invPower > 0.0f) {
            float powerFactor = invPower * powf(interpolated, invPower - 1.0f);
            interpolated = powf(interpolated, invPower);
            dx *= powerFactor;
            dy *= powerFactor;
            dz *= powerFactor;
        }

        threadEnergy = scalingFactor * interpolated;

        atomForce.x = -scalingFactor * dx;
        atomForce.y = -scalingFactor * dy;
        atomForce.z = -scalingFactor * dz;

        // Debug: print force calculation for atom 0 only (critical for comparison)
        // if (index == 0) {
        //     printf("  A0: force=(%.6f, %.6f, %.6f) | gradients=(%.6f, %.6f, %.6f) | scale=%.9f\n",
        //            atomForce.x, atomForce.y, atomForce.z, dx, dy, dz, scalingFactor);
        // }
    }
    else {
        // Apply harmonic restraint outside grid (if enabled)
        // NOTE: This restraint is NOT scaled by scalingFactor - it applies uniformly
        // to all particles to keep them within the grid boundaries
        float3 dev = make_float3(0.0f, 0.0f, 0.0f);

        if (pos.x < 0.0f)
            dev.x = pos.x;
        else if (pos.x > gridCorner.x)
            dev.x = pos.x - gridCorner.x;

        if (pos.y < 0.0f)
            dev.y = pos.y;
        else if (pos.y > gridCorner.y)
            dev.y = pos.y - gridCorner.y;

        if (pos.z < 0.0f)
            dev.z = pos.z;
        else if (pos.z > gridCorner.z)
            dev.z = pos.z - gridCorner.z;

        threadEnergy = 0.5f * outOfBoundsK * (dev.x * dev.x + dev.y * dev.y + dev.z * dev.z);
        atomForce.x = -outOfBoundsK * dev.x;  // Don't scale the out-of-bounds restraint!
        atomForce.y = -outOfBoundsK * dev.y;  // Don't scale the out-of-bounds restraint!
        atomForce.z = -outOfBoundsK * dev.z;  // Don't scale the out-of-bounds restraint!
    }

    // Store forces using atomicAdd with unsigned long long
    // IMPORTANT: Must cast to signed long long first to preserve sign bit!
    unsigned long long fx_fixed = (unsigned long long)((long long)(atomForce.x * 0x100000000));
    unsigned long long fy_fixed = (unsigned long long)((long long)(atomForce.y * 0x100000000));
    unsigned long long fz_fixed = (unsigned long long)((long long)(atomForce.z * 0x100000000));

    // if (index == 0) {
    //     printf("  atomicAdd: indices=(%d, %d, %d) | fixed=(%llu, %llu, %llu)\n",
    //            index, index + paddedNumAtoms, index + 2*paddedNumAtoms,
    //            fx_fixed, fy_fixed, fz_fixed);
    // }

    atomicAdd(&forceBuffers[index], fx_fixed);
    atomicAdd(&forceBuffers[index + paddedNumAtoms], fy_fixed);
    atomicAdd(&forceBuffers[index + 2 * paddedNumAtoms], fz_fixed);

    // Accumulate energy
    atomicAdd(&energyBuffer[0], threadEnergy);
}
